# Физическое хранение данных (Deep Dive)

## Файловая структура PostgreSQL

### Организация файлов

```
$PGDATA/
├── base/              # Базы данных
│   ├── 1/            # template1
│   ├── 13445/        # Ваша БД
│   │   ├── 16384     # Файл таблицы
│   │   ├── 16384.1   # Дополнительный сегмент (если > 1GB)
│   │   └── 16384_fsm # Free Space Map
│   │   └── 16384_vm  # Visibility Map
├── global/           # Общие объекты (роли, базы)
├── pg_wal/          # Write-Ahead Log
├── pg_xact/         # Transaction commit status
└── pg_multixact/    # Multitransaction status
```

### Размер файлов
- По умолчанию макс. размер файла таблицы: **1 GB**
- При превышении создается новый сегмент (.1, .2 и т.д.)
- Настраивается при компиляции (`--with-segsize`)

---

## Страницы (Pages)

### Структура страницы (8 KB по умолчанию)

```
┌─────────────────────────────────────────┐  ← 0 байт
│      Page Header (24 bytes)             │
├─────────────────────────────────────────┤  ← 24
│      Item Pointers (Array)              │  Растут вниз →
│      (4 bytes each)                     │
├─────────────────────────────────────────┤
│                                         │
│      Free Space                         │
│                                         │
├─────────────────────────────────────────┤
│      ← Special Space (для индексов)     │  Опционально
├─────────────────────────────────────────┤
│      ← Tuples (строки)                  │  Растут вверх ←
│      (переменный размер)                │
└─────────────────────────────────────────┘  ← 8192 байта
```

### Page Header (24 bytes)

| Поле | Размер | Описание |
|------|--------|----------|
| `pd_lsn` | 8 bytes | Log Sequence Number (для WAL) |
| `pd_checksum` | 2 bytes | Контрольная сумма страницы |
| `pd_flags` | 2 bytes | Флаги (has_free_lines, has_tuples и т.д.) |
| `pd_lower` | 2 bytes | Смещение конца массива указателей |
| `pd_upper` | 2 bytes | Смещение начала свободного места |
| `pd_special` | 2 bytes | Смещение специального пространства |
| `pd_pagesize_version` | 2 bytes | Размер страницы и версия |
| `pd_prune_xid` | 4 bytes | Oldest unpruned XMAX |

### Item Pointer (Line Pointer) - 4 bytes

```
┌──────────────┬──────────────┬──────────┐
│   lp_off     │   lp_flags   │  lp_len  │
│  (15 bits)   │   (2 bits)   │ (15 bits)│
└──────────────┴──────────────┴──────────┘
```

- `lp_off` - смещение tuple от начала страницы
- `lp_flags` - статус (unused, normal, redirect, dead)
- `lp_len` - длина tuple

---

## Tuple (строка данных)

### Структура Tuple

```
┌─────────────────────────────────────────┐
│      Tuple Header (~23 bytes)           │
├─────────────────────────────────────────┤
│      Null Bitmap (опционально)          │
├─────────────────────────────────────────┤
│      OID (опционально, 4 bytes)         │
├─────────────────────────────────────────┤
│      User Data                          │
│      (столбцы таблицы)                  │
└─────────────────────────────────────────┘
```

### Tuple Header (HeapTupleHeaderData)

| Поле | Размер | Описание |
|------|--------|----------|
| `t_xmin` | 4 bytes | ID транзакции, вставившей tuple |
| `t_xmax` | 4 bytes | ID транзакции, удалившей/обновившей tuple |
| `t_cid` | 4 bytes | Command ID (внутри транзакции) |
| `t_ctid` | 6 bytes | Физический адрес tuple (block + offset) или новой версии |
| `t_infomask2` | 2 bytes | Битовые флаги (число колонок, heap-only tuple) |
| `t_infomask` | 2 bytes | Битовые флаги (XMIN valid, XMAX valid, null values) |
| `t_hoff` | 1 byte | Смещение начала user data |

### Null Bitmap
- По 1 биту на каждый столбец
- Присутствует только если есть NULL значения
- Округляется до байта

---

## TOAST (The Oversized-Attribute Storage Technique)

### Зачем нужен TOAST
- Строка не должна превышать ~2KB (чтобы помещалось несколько строк на страницу 8KB)
- Большие значения (TEXT, BYTEA, JSON) выносятся в отдельную таблицу

### Стратегии TOAST

| Стратегия | Описание |
|-----------|----------|
| **PLAIN** | Без TOAST, без сжатия (для типов фиксированной длины) |
| **EXTENDED** | Сжатие + TOAST (по умолчанию для TEXT, JSON и т.д.) |
| **EXTERNAL** | Только TOAST, без сжатия (для уже сжатых данных) |
| **MAIN** | Сжатие, TOAST только в крайнем случае |

```sql
ALTER TABLE mytable 
ALTER COLUMN data SET STORAGE EXTERNAL;
```

### TOAST таблица

```
pg_toast.pg_toast_<oid>
├── chunk_id    (OID основной строки)
├── chunk_seq   (Номер чанка)
└── chunk_data  (До ~2KB данных)
```

**Пример:**
```sql
CREATE TABLE articles (
    id INT,
    content TEXT  -- Если > 2KB, будет TOAST
);

-- При вставке большого текста:
INSERT INTO articles VALUES (1, repeat('A', 10000));

-- PostgreSQL создаст записи в pg_toast.pg_toast_<oid>:
-- chunk_id=123, chunk_seq=0, chunk_data='AAA...' (2KB)
-- chunk_id=123, chunk_seq=1, chunk_data='AAA...' (2KB)
-- ...
```

---

## Free Space Map (FSM)

### Назначение
- Отслеживает свободное место на каждой странице
- Ускоряет поиск страницы для INSERT
- Файл `<relfilenode>_fsm`

### Структура
- Дерево с 3 уровнями (для таблиц < 1GB)
- Каждый узел хранит макс. свободное место в дочерних страницах
- Точность: 1/256 от размера страницы (~32 байта)

```sql
-- Проверить FSM
SELECT * FROM pg_freespace('mytable');
```

---

## Visibility Map (VM)

### Назначение
- Отмечает страницы, где все tuple видимы для всех транзакций
- Оптимизация VACUUM (пропускает такие страницы)
- Index-Only Scans (можно не читать саму таблицу)
- Файл `<relfilenode>_vm`

### Структура
- Bitmap: 2 бита на страницу
  - Бит 1: all-visible (все tuple видимы)
  - Бит 2: all-frozen (все tuple заморожены)

```sql
-- Проверить VM
SELECT * FROM pg_visibility_map('mytable');
```

---

## Write-Ahead Log (WAL)

### Принцип работы
1. Изменения сначала записываются в WAL
2. Затем применяются к data files (асинхронно)
3. При сбое: replay WAL для восстановления

### Структура WAL записи

```
┌────────────────────────────────────┐
│  WAL Record Header                 │
│  - total length                    │
│  - transaction ID                  │
│  - resource manager ID             │
│  - record type                     │
├────────────────────────────────────┤
│  Data (изменения страницы)         │
│  - block number                    │
│  - offset                          │
│  - old/new tuple data              │
└────────────────────────────────────┘
```

### WAL файлы
- Размер: **16 MB** (по умолчанию)
- Имя: `000000010000000000000001`
  - Timeline ID / Log ID / Segment ID
- После заполнения архивируются или удаляются

### LSN (Log Sequence Number)
- Уникальный адрес в WAL: `<файл>/<смещение>`
- Формат: `0/15D7A40` (WAL file / offset)

### Checkpoints
- Периодическое сохранение всех грязных страниц на диск
- Минимизирует объем WAL для replay
- Настраивается через `checkpoint_timeout`, `max_wal_size`

```sql
-- Принудительный checkpoint
CHECKPOINT;
```

---

## InnoDB Storage Engine (MySQL)

### Файловая структура InnoDB

```
/var/lib/mysql/
├── ibdata1              # Системный tablespace (undo logs, rollback segments)
├── ib_logfile0          # Redo log (циклический буфер)
├── ib_logfile1          # Redo log
├── mysql/               # Системная БД
├── your_database/       # Ваша БД
│   ├── table1.ibd      # Данные и индексы таблицы (file-per-table)
│   └── table2.ibd
└── undo_001            # Отдельные undo tablespaces (MySQL 8.0+)
    undo_002
```

**Режимы tablespace:**
- **System tablespace** (`ibdata1`) - все таблицы в одном файле (старый подход)
- **File-per-table** (`innodb_file_per_table=1`) - каждая таблица в `.ibd` (рекомендуется)

---

### InnoDB Redo Log (журнал повтора)

#### Назначение
- **Crash recovery** - восстановление после сбоя
- **Долговечность (Durability)** - гарантия сохранности закоммиченных транзакций
- **Write-Ahead Logging** - сначала пишем лог, потом данные

#### Структура

```
┌──────────────────────────────────────────┐
│  ib_logfile0 (512MB - 4GB)              │
│  ┌────────────────────────────────────┐  │
│  │  Redo Record 1                     │  │
│  │  - Space ID                        │  │
│  │  - Page Number                     │  │
│  │  - Operation Type (INSERT/UPDATE)  │  │
│  │  - Changed Bytes                   │  │
│  ├────────────────────────────────────┤  │
│  │  Redo Record 2                     │  │
│  │  ...                               │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘
         ↓ (циклическая запись)
┌──────────────────────────────────────────┐
│  ib_logfile1                            │
└──────────────────────────────────────────┘
```

**Циклический буфер:**
- 2+ файла фиксированного размера (`innodb_log_file_size`)
- Запись идет по кругу (file0 → file1 → file0...)
- Старые записи перезаписываются после checkpoint

#### Как работает

**При записи данных:**
```
1. Транзакция изменяет данные
   ↓
2. Изменения попадают в InnoDB Buffer Pool (в памяти)
   - Страницы помечаются как dirty
   ↓
3. ОДНОВРЕМЕННО записываются в Redo Log Buffer (в памяти)
   ↓
4. При COMMIT:
   - Redo Log Buffer → fsync на диск (ib_logfile)
   - Гарантия: запись в redo log РАНЬШЕ возврата OK клиенту
   ↓
5. Dirty pages сбрасываются на диск ПОЗЖЕ (асинхронно)
   - Фоновые потоки (page cleaner threads)
   - При checkpoint
```

**Параметр `innodb_flush_log_at_trx_commit`:**
```ini
# Значение 1 (ACID compliant, по умолчанию)
innodb_flush_log_at_trx_commit = 1
# - Redo log buffer → OS cache → fsync на диск при каждом COMMIT
# - Гарантия долговечности, но медленнее

# Значение 0 (быстрее, НЕ ACID)
innodb_flush_log_at_trx_commit = 0
# - fsync раз в секунду
# - Можем потерять до 1 секунды транзакций при сбое

# Значение 2 (компромисс)
innodb_flush_log_at_trx_commit = 2
# - Redo log buffer → OS cache при COMMIT (но не fsync)
# - fsync раз в секунду
# - Защита от краха MySQL, но не от краха ОС
```

**Crash Recovery:**
```sql
-- При старте MySQL после сбоя:
1. Читает ib_logfile0, ib_logfile1
2. Применяет (redo) все закоммиченные транзакции из лога
3. Откатывает (undo) незакоммиченные через undo logs
4. Восстановление завершено
```

**Размер redo log:**
```ini
innodb_log_file_size = 1G    # Размер одного файла
innodb_log_files_in_group = 2  # Количество файлов (обычно 2)
# Общий размер = 1G * 2 = 2GB

# Trade-off:
# Больше размер = реже checkpoint = выше производительность записи
# Меньше размер = быстрее восстановление после сбоя
```

**LSN (Log Sequence Number):**
- Монотонно растущий номер в redo log
- Каждая страница хранит LSN последнего изменения
- При восстановлении: применяются только записи с LSN > page LSN

```sql
-- Посмотреть текущий LSN
SHOW ENGINE INNODB STATUS\G

-- Вывод:
-- Log sequence number          12345678901
-- Log flushed up to            12345678900  (записано на диск)
-- Pages flushed up to          12345600000  (dirty pages сброшены)
-- Last checkpoint at           12345500000  (последний checkpoint)
```

---

### InnoDB Undo Log (журнал отката)

#### Назначение
- **Rollback** - откат незакоммиченных транзакций
- **MVCC** - читаем старые версии строк для изоляции
- **Crash recovery** - откат незавершенных транзакций

#### Структура

```
┌─────────────────────────────────────────┐
│  Undo Tablespace (undo_001, undo_002)   │
│  ┌───────────────────────────────────┐  │
│  │  Undo Log Segment 1               │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │ Undo Record (для UPDATE)    │  │  │
│  │  │ - Table ID                  │  │  │
│  │  │ - Primary Key               │  │  │
│  │  │ - OLD VALUES (до изменения) │  │  │
│  │  │ - Transaction ID            │  │  │
│  │  └─────────────────────────────┘  │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │ Undo Record (для INSERT)    │  │  │
│  │  │ - Primary Key (для DELETE)  │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

**Типы undo records:**
- **INSERT undo** - хранит primary key (для отката DELETE этой строки)
- **UPDATE undo** - хранит старые значения колонок (для отката UPDATE)

#### MVCC через Undo Logs

**Структура строки в InnoDB:**
```
┌──────────────────────────────────────────────────┐
│  Row Header                                      │
│  - DB_TRX_ID (6 bytes) - ID транзакции          │  Кто изменил
│  - DB_ROLL_PTR (7 bytes) - указатель на undo    │  Где старая версия
│  - DB_ROW_ID (6 bytes) - row ID (если нет PK)   │
├──────────────────────────────────────────────────┤
│  Данные колонок                                  │
└──────────────────────────────────────────────────┘
```

**Пример MVCC:**
```sql
-- Исходное состояние (TRX_ID = 100)
id | name   | balance | DB_TRX_ID | DB_ROLL_PTR
---+--------+---------+-----------+-------------
1  | Alice  | 1000    | 100       | NULL

-- TX 200: UPDATE
UPDATE accounts SET balance = 1500 WHERE id = 1;

-- Новая версия в таблице (TRX_ID = 200)
id | name   | balance | DB_TRX_ID | DB_ROLL_PTR
---+--------+---------+-----------+------------------
1  | Alice  | 1500    | 200       | → Undo Record

-- Undo Record (старая версия):
-- balance = 1000, TRX_ID = 100, ROLL_PTR = NULL

-- TX 150 (старая транзакция) читает:
SELECT balance FROM accounts WHERE id = 1;
-- Видит TRX_ID=200 > 150 (не должна видеть)
-- → Идет по ROLL_PTR в undo log
-- → Читает balance = 1000
```

**Read View (снимок транзакций):**
- При `START TRANSACTION` создается Read View
- Содержит список активных транзакций
- Определяет видимость строк:
  - `TRX_ID < min_active` - видна
  - `TRX_ID > max_active` - не видна
  - `TRX_ID in active_list` - не видна (идем в undo)

#### Purge (очистка undo logs)

```sql
-- Старые undo records не нужны когда:
-- 1. Транзакция закоммичена
-- 2. Никакая активная транзакция не может читать эту версию

-- Purge thread периодически удаляет старые undo records
SHOW ENGINE INNODB STATUS\G

-- Вывод:
-- History list length 1523  ← Количество unpurged undo records
-- Если растет → медленный purge или долгие транзакции
```

**Проблемы с Undo:**
- **Долгая транзакция** блокирует purge → undo logs растут → ibdata1 раздувается
- **Решение:**
  - Избегать длинных транзакций
  - Мониторить `History list length`
  - MySQL 8.0+: отдельные undo tablespaces (можно truncate)

```ini
# MySQL 8.0+ настройки undo
innodb_undo_tablespaces = 2       # Количество undo tablespaces
innodb_undo_log_truncate = ON     # Автоочистка
innodb_max_undo_log_size = 1G     # Макс размер перед truncate
```

---

### Binary Log (binlog)

#### Назначение
- **Репликация** - передача изменений на replicas
- **Point-in-time recovery** - восстановление на момент времени
- **Аудит** - история изменений

**Отличие от Redo Log:**
- **Redo log** - низкоуровневые изменения страниц (crash recovery)
- **Binlog** - логические SQL операции (репликация, бэкапы)

#### Форматы записи

```ini
binlog_format = ROW        # Рекомендуется
# binlog_format = STATEMENT  # SQL запросы (компактнее, но проблемы с недетерминированными функциями)
# binlog_format = MIXED      # Автовыбор
```

**ROW format (построчный):**
```
-- Запрос:
UPDATE users SET balance = balance + 100 WHERE city = 'Moscow';

-- Binlog (ROW):
### UPDATE `db`.`users`
### WHERE
###   @1=1 @2='Alice' @3=1000 @4='Moscow'  ← Старые значения
### SET
###   @1=1 @2='Alice' @3=1100 @4='Moscow'  ← Новые значения
### UPDATE `db`.`users`
### WHERE
###   @1=2 @2='Bob' @3=500 @4='Moscow'
### SET
###   @1=2 @2='Bob' @3=600 @4='Moscow'
-- ... для каждой измененной строки
```

**STATEMENT format:**
```
-- Binlog (STATEMENT):
UPDATE users SET balance = balance + 100 WHERE city = 'Moscow';
-- Компактнее, но проблемы с NOW(), RAND(), UUID()
```

#### Структура binlog

```
/var/lib/mysql/
├── mysql-bin.000001     # Binlog файлы (ротация по размеру/времени)
├── mysql-bin.000002
├── mysql-bin.index      # Индекс файлов
└── relay-log.000001     # Relay logs на replica (промежуточный буфер)
```

**Ротация:**
```sql
-- Вручную
FLUSH BINARY LOGS;

-- Автоматически при:
-- - Размер > max_binlog_size (по умолчанию 1GB)
-- - Перезапуск сервера
-- - FLUSH LOGS
```

#### Binlog и транзакции

```
1. Транзакция выполняется
   ↓
2. При COMMIT:
   - Записывается в redo log (innodb_flush_log_at_trx_commit)
   - ПОТОМ записывается в binlog
   - Двухфазный коммит (2PC) для консистентности
   ↓
3. Binlog → replicas (асинхронно или полусинхронно)
```

**Двухфазный коммит (2PC):**
```
Phase 1: PREPARE
  - InnoDB готовится к коммиту (пишет redo log)
  - Binlog записывает событие

Phase 2: COMMIT
  - InnoDB коммитит транзакцию
  - Binlog коммитит (finalize)

-- Гарантия: redo log и binlog синхронны
-- При краше: либо оба закоммичены, либо оба откатятся
```

#### Посмотреть binlog

```sql
-- Список binlog файлов
SHOW BINARY LOGS;

-- Текущая позиция
SHOW MASTER STATUS;
-- Вывод:
-- File: mysql-bin.000003
-- Position: 123456789

-- Читать содержимое
SHOW BINLOG EVENTS IN 'mysql-bin.000003' LIMIT 10;

-- Или через mysqlbinlog (CLI)
```

```bash
# Утилита mysqlbinlog
mysqlbinlog mysql-bin.000003

# Конвертировать в SQL для recovery
mysqlbinlog mysql-bin.000003 > recovery.sql
mysql -u root -p < recovery.sql

# Point-in-time recovery (до определенного момента)
mysqlbinlog --stop-datetime="2026-01-31 12:00:00" mysql-bin.000003 > recovery.sql
```

**Настройки:**
```ini
# Включить binlog
log_bin = /var/lib/mysql/mysql-bin
server_id = 1  # Уникальный ID сервера (для репликации)

# Формат
binlog_format = ROW

# Размер файла
max_binlog_size = 1G

# Хранить N дней
binlog_expire_logs_seconds = 604800  # 7 дней (MySQL 8.0+)
expire_logs_days = 7                  # Старая настройка

# Синхронизация (durability)
sync_binlog = 1  # fsync после каждой транзакции (ACID)
# sync_binlog = 0  # ОС решает (быстрее, но можем потерять транзакции)
```

---

### Полная последовательность записи в InnoDB (все 3 лога)

**Пример: `UPDATE users SET balance = 1000 WHERE id = 5;`**

```
┌────────────────────────────────────────────────────────────────────┐
│  1. START TRANSACTION                                              │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  2. Чтение текущей строки (id=5)                                  │
│     - Читаем из Buffer Pool (или загружаем с диска)               │
│     - Текущее значение: balance = 500, TRX_ID = 100               │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  3. Запись в Undo Log (ПЕРЕД изменением данных)                   │
│     ┌──────────────────────────────────────────────────────────┐  │
│     │ Undo Record:                                             │  │
│     │ - Table ID: users                                        │  │
│     │ - Primary Key: id=5                                      │  │
│     │ - OLD VALUES: balance=500, TRX_ID=100                    │  │
│     │ - Указатель на предыдущий undo (цепочка версий)          │  │
│     └──────────────────────────────────────────────────────────┘  │
│     Цель: rollback + MVCC (старые транзакции прочитают 500)       │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  4. Изменение данных в Buffer Pool (в памяти)                     │
│     ┌──────────────────────────────────────────────────────────┐  │
│     │ Новая версия строки:                                     │  │
│     │ - id=5, balance=1000, TRX_ID=200 (текущая транзакция)    │  │
│     │ - DB_ROLL_PTR → указатель на Undo Record (баланс=500)    │  │
│     └──────────────────────────────────────────────────────────┘  │
│     Страница помечается как DIRTY (modified in memory)             │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  5. Запись в Redo Log Buffer (физические изменения)               │
│     ┌──────────────────────────────────────────────────────────┐  │
│     │ Redo Record (ФИЗИЧЕСКИЙ уровень):                        │  │
│     │ - Space ID: 42 (tablespace users.ibd)                    │  │
│     │ - Page Number: 123                                       │  │
│     │ - Offset: 456 (смещение в странице)                      │  │
│     │ - Operation: UPDATE                                      │  │
│     │ - Changed Bytes: [0x00, 0x03, 0xE8, ...] (1000 в hex)    │  │
│     │ - LSN: 98765432 (Log Sequence Number)                    │  │
│     └──────────────────────────────────────────────────────────┘  │
│     НЕ построчные данные, а низкоуровневые байты страницы!         │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  6. COMMIT                                                         │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  7. Двухфазный коммит (2PC) - Phase 1: PREPARE                    │
│     ┌──────────────────────────────────────────────────────────┐  │
│     │ A. Redo Log Buffer → fsync на диск (ib_logfile0)         │  │
│     │    - innodb_flush_log_at_trx_commit=1: fsync сразу       │  │
│     │    - Гарантия: redo записан РАНЬШЕ возврата OK клиенту   │  │
│     │    - LSN обновлен: Log flushed up to 98765432            │  │
│     └──────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  8. Двухфазный коммит (2PC) - Phase 2: BINLOG                     │
│     ┌──────────────────────────────────────────────────────────┐  │
│     │ B. Запись в Binary Log (ЛОГИЧЕСКИЙ уровень)              │  │
│     │                                                           │  │
│     │    STATEMENT format:                                      │  │
│     │    UPDATE users SET balance=1000 WHERE id=5;              │  │
│     │                                                           │  │
│     │    ROW format:                                            │  │
│     │    ### UPDATE `db`.`users`                                │  │
│     │    ### WHERE @1=5 @2=500    ← Старые значения            │  │
│     │    ### SET   @1=5 @2=1000   ← Новые значения             │  │
│     │                                                           │  │
│     │ - sync_binlog=1: fsync после каждой транзакции            │  │
│     │ - Position обновлен: 123456789 → 123456890                │  │
│     └──────────────────────────────────────────────────────────┘  │
│     Цель: репликация на slaves + point-in-time recovery            │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  9. Коммит завершен → OK клиенту                                  │
│     Гарантия ACID: redo + binlog на диске                          │
└────────────────────────────────────────────────────────────────────┘
                             ↓
┌────────────────────────────────────────────────────────────────────┐
│  10. ПОЗЖЕ (асинхронно, фоновые потоки)                           │
│      ┌─────────────────────────────────────────────────────────┐  │
│      │ A. Page Cleaner Thread:                                 │  │
│      │    - Dirty page из Buffer Pool → диск (users.ibd)       │  │
│      │    - Обновляет LSN на странице: 98765432                │  │
│      │    - Освобождает место в Buffer Pool                    │  │
│      │                                                          │  │
│      │ B. Purge Thread:                                        │  │
│      │    - Удаляет старые undo records (balance=500)          │  │
│      │    - Когда нет активных транзакций с Read View < 200    │  │
│      │    - Освобождает место в undo tablespace                │  │
│      │                                                          │  │
│      │ C. Checkpoint:                                          │  │
│      │    - Периодически сбрасывает все dirty pages            │  │
│      │    - Обновляет Last checkpoint LSN                      │  │
│      │    - Redo log можно перезаписать с этой позиции         │  │
│      └─────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────┘
```

**Ключевые моменты:**

1. **Undo пишется ПЕРВЫМ** (до изменения данных) - для rollback
2. **Buffer Pool изменяется в памяти** - страница становится dirty
3. **Redo записывается в память** (Redo Log Buffer) - физические изменения страницы
4. **При COMMIT:**
   - Сначала Redo → fsync (InnoDB готов к crash recovery)
   - Потом Binlog → fsync (репликация и бэкапы)
   - Двухфазный коммит гарантирует согласованность
5. **Dirty pages сбрасываются позже** - производительность (не ждем I/O при каждом COMMIT)
6. **Undo очищается purge thread'ом** - когда старые версии больше не нужны

**Что хранится в каждом логе:**

| Лог | Уровень | Что хранит | Пример |
|-----|---------|------------|--------|
| **Undo Log** | Логический (строки) | Старые значения колонок | `balance=500, TRX_ID=100` |
| **Redo Log** | Физический (страницы) | Байты изменений в странице | `Page 123, offset 456, bytes [0xE8, 0x03]` |
| **Binlog** | Логический (SQL/строки) | SQL команды или ROW данные | `UPDATE users SET balance=1000 WHERE id=5` |

---

### Сравнение: PostgreSQL WAL vs InnoDB Logs

| Характеристика | PostgreSQL WAL | InnoDB Redo Log | InnoDB Undo Log | MySQL Binlog |
|----------------|----------------|-----------------|-----------------|--------------|
| **Назначение** | Crash recovery + репликация | Crash recovery | Rollback + MVCC | Репликация + PITR |
| **Уровень** | Физический (страницы) | Физический (страницы) | Логический (строки) | Логический (SQL/строки) |
| **Размер** | Растет (архивируется) | Фиксированный (циклический) | Растет (purge) | Растет (ротация) |
| **MVCC** | Tuple versioning в таблице | - | Через undo chains | - |
| **Репликация** | Streaming/Physical | - | - | Master→Replica |
| **Долговечность** | Да (fsync при commit) | Да (fsync при commit) | - | Опционально |

**Ключевые отличия:**
- **PostgreSQL:** WAL для всего (crash recovery + репликация), MVCC через tuple versioning
- **MySQL/InnoDB:** 3 раздельных лога (redo для crash, undo для MVCC, binlog для репликации)
- **PostgreSQL WAL** растет и архивируется, **InnoDB redo** циклический фиксированного размера
- **PostgreSQL MVCC:** старые версии в таблице (VACUUM чистит), **InnoDB MVCC:** старые версии в undo (purge чистит)

---

## Индексы (физическое устройство)

### B-Tree индекс

#### Структура страницы B-Tree

```
┌─────────────────────────────────────────┐
│      Meta Page (root, уровень дерева)   │  Страница 0
├─────────────────────────────────────────┤
│      Root Page                          │  Страница 1
│  ┌──────┬──────┬──────┐                 │
│  │ <=10 │ <=20 │ <=30 │ (указатели)    │
│  └──────┴──────┴──────┘                 │
├─────────────────────────────────────────┤
│      Internal Page                      │  Страница 2
│  ┌───┬───┬───┬───┐                      │
│  │<=5│<=8│...│     │                    │
│  └───┴───┴───┴───┘                      │
├─────────────────────────────────────────┤
│      Leaf Page                          │  Страница 3
│  ┌─────────────────────────────────┐    │
│  │ Key=1, TID=(page=10, offset=1) │    │  TID = Tuple ID
│  │ Key=2, TID=(page=10, offset=2) │    │
│  │ ...                             │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**Leaf pages содержат:**
- Indexed key value
- TID (Tuple Identifier): блок + смещение в heap таблице

**Поиск по B-Tree:**
1. Читаем meta page → находим root
2. Читаем root → бинарный поиск → переход на internal page
3. Читаем internal → переход на leaf page
4. Читаем leaf → находим TID
5. Читаем heap page по TID → получаем данные

### Hash индекс

- Страницы разбиты на buckets
- Hash function определяет bucket
- Каждый bucket - linked list страниц
- **Не поддерживает:** ORDER BY, range scans
- **Поддерживает:** только равенство `=`

### GiST (Generalized Search Tree)

- Универсальный индекс для custom типов
- Используется для: геометрия (PostGIS), full-text search, ltree
- Сбалансированное дерево с предикатами

### GIN (Generalized Inverted Index)

- Для составных значений: массивы, JSONB, full-text
- Структура: posting tree + posting lists

```
┌────────────────────────────────┐
│  Entry Tree (B-Tree)           │
│  ┌───────┬───────┬───────┐     │
│  │ word1 │ word2 │ word3 │     │
│  └───┬───┴───┬───┴───┬───┘     │
│      │       │       │         │
├──────┼───────┼───────┼─────────┤
│  Posting Lists                 │
│  word1 → [TID1, TID5, TID9]    │
│  word2 → [TID2, TID3]          │
│  word3 → [TID1, TID8, TID10]   │
└────────────────────────────────┘
```

### BRIN (Block Range Index)

- Минимальная/максимальная граница для диапазона страниц
- Очень маленький размер индекса
- Эффективен для отсортированных данных

```
┌────────────────────────────────┐
│  Pages 0-999:   min=1, max=100 │
│  Pages 1000-1999: min=101, max=200│
│  Pages 2000-2999: min=201, max=300│
└────────────────────────────────┘
```

---

## Процесс INSERT

1. **Выделение места:**
   - Проверка FSM для поиска страницы со свободным местом
   - Если нет места → выделение новой страницы

2. **Запись tuple:**
   - Формирование tuple (header + null bitmap + data)
   - TOAST для больших значений
   - Запись в heap page

3. **Обновление индексов:**
   - Вставка в каждый индекс (key → TID)

4. **WAL запись:**
   - Запись изменений в WAL
   - fsync (если синхронный commit)

5. **Обновление метаданных:**
   - FSM (уменьшение свободного места)
   - VM (сброс флага all-visible)

---

## Процесс UPDATE

### В PostgreSQL UPDATE = DELETE + INSERT

1. **Старая версия:**
   - Установка `xmax` = текущий XID
   - Tuple становится "dead" после коммита

2. **Новая версия:**
   - Создание нового tuple с `xmin` = текущий XID
   - `t_ctid` старой версии → новая версия

3. **HOT Update (Heap-Only Tuple):**
   - Оптимизация: если новая версия помещается на ту же страницу
   - И обновленные столбцы не индексированы
   - Индексы не обновляются!

```sql
-- HOT update возможен
UPDATE users SET last_login = NOW() WHERE id = 1;

-- HOT update НЕвозможен (обновляем индексированный столбец)
UPDATE users SET email = 'new@email.com' WHERE id = 1;
```

---

## Bloat и VACUUM

### Причины Bloat
- Мертвые tuple после UPDATE/DELETE
- Неиспользуемое пространство
- TOAST bloat

### VACUUM процесс

1. **Сканирование таблицы:**
   - Чтение каждой страницы
   - Проверка visibility каждого tuple

2. **Удаление мертвых tuple:**
   - Помечаются как unused
   - Обновление FSM

3. **Обновление индексов:**
   - Удаление ссылок на мертвые tuple

4. **Truncate:**
   - Освобождение пустых страниц в конце файла

### VACUUM FULL

- Полная перестройка таблицы
- Создание нового файла без bloat
- **Блокирует** таблицу (ACCESS EXCLUSIVE)
- Освобождает место в ОС

```sql
-- Обычный VACUUM
VACUUM mytable;

-- С анализом статистики
VACUUM ANALYZE mytable;

-- Полная очистка (долгая операция!)
VACUUM FULL mytable;
```

### Autovacuum

```sql
-- Настройки autovacuum
ALTER TABLE mytable SET (
    autovacuum_vacuum_scale_factor = 0.1,  -- 10% мертвых строк
    autovacuum_vacuum_threshold = 50       -- Минимум 50 мертвых строк
);
```

---

## Ключевые вопросы для интервью

### PostgreSQL
- Из каких частей состоит страница в PostgreSQL?
- Как хранятся строки больше 2KB? (TOAST)
- Зачем нужны FSM и VM?
- Чем отличается VACUUM от VACUUM FULL?
- Что такое HOT update и когда он возможен?
- Как работает WAL и зачем нужны checkpoints?
- Как B-Tree индекс связан с heap таблицей?
- Что происходит при UPDATE на физическом уровне?
- Почему UPDATE в PostgreSQL создает новую версию строки?
- Как PostgreSQL реализует MVCC? (tuple versioning)

### InnoDB (MySQL)
- В чем разница между redo log, undo log и binlog?
- Как работает crash recovery в InnoDB?
- Что такое LSN и где он используется?
- Зачем нужны undo logs и как они связаны с MVCC?
- Что значит `innodb_flush_log_at_trx_commit=1` и почему это важно для ACID?
- Почему redo log циклический, а binlog растет?
- Что такое двухфазный коммит (2PC) между redo и binlog?
- Как InnoDB читает старые версии строк? (DB_ROLL_PTR)
- Что произойдет если History list length растет?
- В чем разница между file-per-table и system tablespace?

### Сравнение
- Чем отличается WAL в PostgreSQL от redo log в InnoDB?
- Как PostgreSQL и InnoDB по-разному реализуют MVCC?
- Почему в PostgreSQL нужен VACUUM, а в InnoDB - purge thread?
